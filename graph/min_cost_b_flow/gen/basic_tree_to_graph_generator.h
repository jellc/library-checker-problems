#ifndef MIN_COST_B_FLOW_GEN_TREE_TO_GRAPH_GENERATOR_H
#define MIN_COST_B_FLOW_GEN_TREE_TO_GRAPH_GENERATOR_H

#include <numeric>
#include <vector>

#include "common.h"

namespace basic_tree_to_graph_generator {

struct Generator {
    using Tree = std::vector<std::pair<size_t, size_t>>;
    virtual ~Generator() = default;

    virtual Cost get_cost_limit() const { return C_MAX; }
    virtual Flow get_flow_limit() const { return U_MAX; }

    virtual Tree generate_tree(const size_t n) = 0;
    virtual Cost gen_potential(const Cost upper) = 0;
    virtual Flow gen_flow_for_tree_edge(const Flow lower, const Flow upper) = 0;
    virtual Flow gen_lower_for_tree_edge(const Flow lower, const Flow flow) = 0;
    virtual Flow gen_upper_for_tree_edge(const Flow flow, const Flow upper) = 0;

    virtual std::pair<size_t, size_t> gen_non_tree_edge(const size_t n) = 0;
    virtual Flow gen_flow_for_non_tree_edge(const Flow lower, const Flow upper) = 0;
    virtual Flow gen_upper_for_lower_non_tree_edge(const Flow flow, const Flow upper) = 0;
    virtual Cost gen_cost_for_lower_non_tree_edge(const Cost pot_diff, const Cost upper) = 0;

    Graph generate(const size_t n, const size_t m) {
        assert(m >= n - 1);

        const auto c_max = get_cost_limit();
        const auto u_max = get_flow_limit();

        const auto tree = generate_tree(n);

        std::vector<Cost> potential(n);
        for (auto &p : potential) p = gen_potential(c_max);
        Graph graph(n);

        for (const auto& edge : tree) {
            const auto s = edge.first;
            const auto t = edge.second;
            const auto f_min = std::max({-u_max, -u_max - graph.bs[s], -u_max + graph.bs[t]});
            const auto f_max = std::min({+u_max, +u_max - graph.bs[s], +u_max + graph.bs[t]});
            const auto flow = gen_flow_for_tree_edge(f_min, f_max);
            const auto lower = gen_lower_for_tree_edge(f_min, flow);
            const auto upper = gen_upper_for_tree_edge(flow, f_max);
            const auto cost = potential[t] - potential[s];
            graph.add_edge(s, t, lower, upper, cost);
            graph.bs[s] += flow;
            graph.bs[t] -= flow;
        }
        while (graph.num_edges() < m) {
            const auto edge = gen_non_tree_edge(n);
            const auto s = edge.first;
            const auto t = edge.second;
            const auto f_min = std::max({-u_max, -u_max - graph.bs[s], -u_max + graph.bs[t]});
            const auto f_max = std::min({+u_max, +u_max - graph.bs[s], +u_max + graph.bs[t]});
            const auto flow = gen_flow_for_non_tree_edge(f_min, f_max);
            const auto cost_base = potential[t] - potential[s];
            // We generate lower edge only. Upper edges can be generated by edge flipping.
            const auto upper = gen_upper_for_lower_non_tree_edge(flow, f_max);
            const auto cost = gen_cost_for_lower_non_tree_edge(cost_base, c_max);
            graph.add_edge(s, t, flow, upper, cost);
            graph.bs[s] += flow;
            graph.bs[t] -= flow;
        }
        return graph;
    }
};

template<class RNG>
std::vector<std::pair<size_t, size_t>> generate_tree(RNG &rng, const size_t n) {
    std::vector<size_t> added;
    auto unused = rng.template perm<size_t>(n);
    added.emplace_back(unused.back());
    unused.pop_back();
    std::vector<std::pair<size_t, size_t>> res;
    while (!unused.empty()) {
        const auto child = unused.back();
        unused.pop_back();
        const auto parent = added[rng.template uniform<size_t>(0, added.size()-1)];
        res.emplace_back(parent, child);
        added.emplace_back(child);
    }
    return res;
}
template<class RNG>
std::vector<std::pair<size_t, size_t>> generate_skewed_tree(RNG &rng, const size_t n) {
    std::vector<size_t> added;
    auto unused = rng.template perm<size_t>(n);
    added.emplace_back(unused.back());
    unused.pop_back();
    std::vector<std::pair<size_t, size_t>> res;
    while (!unused.empty()) {
        const auto child = unused.back();
        unused.pop_back();
        const auto parent = added[rng.skewed(added.size()-1)];
        res.emplace_back(parent, child);
        added.emplace_back(child);
    }
    return res;
}

} // namespace basic_tree_to_graph_generator

#endif // MIN_COST_B_FLOW_GEN_TREE_TO_GRAPH_GENERATOR_H
